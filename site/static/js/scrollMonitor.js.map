{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///scrollMonitor.js","webpack:///webpack/bootstrap b221bc136e7e9b3db562","webpack:///./index.js","webpack:///./src/constants.js","webpack:///./src/container.js","webpack:///./src/watcher.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_require","isInBrowser","ScrollMonitorContainer","scrollMonitor","document","body","setStateFromDOM","listenToDOM","window","VISIBILITYCHANGE","ENTERVIEWPORT","FULLYENTERVIEWPORT","EXITVIEWPORT","PARTIALLYEXITVIEWPORT","LOCATIONCHANGE","STATECHANGE","eventTypes","isOnServer","defaultOffsets","top","bottom","_classCallCheck","instance","Constructor","TypeError","getViewportHeight","element","innerHeight","documentElement","clientHeight","getContentHeight","Math","max","scrollHeight","offsetHeight","scrollTop","pageYOffset","Watcher","browserSupportsPassive","opts","Object","defineProperty","get","addEventListener","e","useCapture","capture","passive","item","parentWatcher","calculateViewport","self","viewportTop","viewportBottom","viewportHeight","documentHeight","previousDocumentHeight","calculateViewportI","watchers","length","recalculateLocation","updateAndTriggerWatchers","updateAndTriggerWatchersI","update","triggerCallbacks","DOMListener","prototype","apply","arguments","containerWatcher","create","recalculateLocations","attachEvent","destroy","removeEventListener","detachEvent","event","contentHeight","setState","newViewportTop","newViewportHeight","newContentHeight","needsRecalcuate","latestEvent","i","createCustomContainer","createContainer","querySelector","container","offsets","watcher","push","beget","ElementWatcher","watchItem","triggerCallbackArray","listeners","listenerToTriggerListI","listener","callback","isOne","splice","callbacks","j","locked","wasInViewport","wasFullyInViewport","wasAboveViewport","wasBelowViewport","isInViewport","isFullyInViewport","isAboveViewport","isBelowViewport","previousTop","previousBottom","nodeName","cachedDisplay","style","display","containerOffset","boundingRect","getBoundingClientRect","height","undefined","on","Error","join","off","one","recalculateSize","index","indexOf","lock","unlock","eventHandlerFactory","type"],"mappings":"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","file":"scrollMonitor.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"scrollMonitor\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scrollMonitor\"] = factory();\n\telse\n\t\troot[\"scrollMonitor\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    isInBrowser = _require.isInBrowser;\n\t\n\tvar ScrollMonitorContainer = __webpack_require__(2);\n\t\n\tvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\n\tscrollMonitor.setStateFromDOM(null);\n\tscrollMonitor.listenToDOM();\n\t\n\tif (isInBrowser) {\n\t\twindow.scrollMonitor = scrollMonitor;\n\t}\n\t\n\tmodule.exports = scrollMonitor;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\texports.VISIBILITYCHANGE = 'visibilityChange';\n\texports.ENTERVIEWPORT = 'enterViewport';\n\texports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\n\texports.EXITVIEWPORT = 'exitViewport';\n\texports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\n\texports.LOCATIONCHANGE = 'locationChange';\n\texports.STATECHANGE = 'stateChange';\n\t\n\texports.eventTypes = [exports.VISIBILITYCHANGE, exports.ENTERVIEWPORT, exports.FULLYENTERVIEWPORT, exports.EXITVIEWPORT, exports.PARTIALLYEXITVIEWPORT, exports.LOCATIONCHANGE, exports.STATECHANGE];\n\t\n\texports.isOnServer = typeof window === 'undefined';\n\texports.isInBrowser = !exports.isOnServer;\n\t\n\texports.defaultOffsets = { top: 0, bottom: 0 };\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tvar _require = __webpack_require__(1),\n\t    isOnServer = _require.isOnServer,\n\t    isInBrowser = _require.isInBrowser,\n\t    eventTypes = _require.eventTypes;\n\t\n\tvar Watcher = __webpack_require__(3);\n\t\n\tfunction getViewportHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t\t} else {\n\t\t\treturn element.clientHeight;\n\t\t}\n\t}\n\t\n\tfunction getContentHeight(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\n\t\tif (element === document.body) {\n\t\t\t// jQuery approach\n\t\t\t// whichever is greatest\n\t\t\treturn Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.documentElement.clientHeight);\n\t\t} else {\n\t\t\treturn element.scrollHeight;\n\t\t}\n\t}\n\t\n\tfunction scrollTop(element) {\n\t\tif (isOnServer) {\n\t\t\treturn 0;\n\t\t}\n\t\tif (element === document.body) {\n\t\t\treturn window.pageYOffset || document.documentElement && document.documentElement.scrollTop || document.body.scrollTop;\n\t\t} else {\n\t\t\treturn element.scrollTop;\n\t\t}\n\t}\n\t\n\tvar browserSupportsPassive = false;\n\tif (isInBrowser) {\n\t\ttry {\n\t\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\t\tget: function get() {\n\t\t\t\t\tbrowserSupportsPassive = true;\n\t\t\t\t}\n\t\t\t});\n\t\t\twindow.addEventListener('test', null, opts);\n\t\t} catch (e) {}\n\t}\n\tvar useCapture = browserSupportsPassive ? { capture: false, passive: true } : false;\n\t\n\tvar ScrollMonitorContainer = function () {\n\t\tfunction ScrollMonitorContainer(item, parentWatcher) {\n\t\t\t_classCallCheck(this, ScrollMonitorContainer);\n\t\n\t\t\tvar self = this;\n\t\n\t\t\tthis.item = item;\n\t\t\tthis.watchers = [];\n\t\t\tthis.viewportTop = null;\n\t\t\tthis.viewportBottom = null;\n\t\t\tthis.documentHeight = getContentHeight(item);\n\t\t\tthis.viewportHeight = getViewportHeight(item);\n\t\t\tthis.DOMListener = function () {\n\t\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t\t};\n\t\t\tthis.eventTypes = eventTypes;\n\t\n\t\t\tif (parentWatcher) {\n\t\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t\t}\n\t\n\t\t\tvar previousDocumentHeight;\n\t\n\t\t\tvar calculateViewportI;\n\t\t\tfunction calculateViewport() {\n\t\t\t\tself.viewportTop = scrollTop(item);\n\t\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\t\twhile (calculateViewportI--) {\n\t\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t\t}\n\t\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tvar updateAndTriggerWatchersI;\n\t\t\tfunction updateAndTriggerWatchers() {\n\t\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t\t}\n\t\n\t\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\t\twhile (updateAndTriggerWatchersI--) {\n\t\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tthis.update = function () {\n\t\t\t\tcalculateViewport();\n\t\t\t\tupdateAndTriggerWatchers();\n\t\t\t};\n\t\t\tthis.recalculateLocations = function () {\n\t\t\t\tthis.documentHeight = 0;\n\t\t\t\tthis.update();\n\t\t\t};\n\t\t}\n\t\n\t\tScrollMonitorContainer.prototype.listenToDOM = function listenToDOM() {\n\t\t\tif (isInBrowser) {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t}\n\t\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t\tthis.destroy = function () {\n\t\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// Old IE support\n\t\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.destroy = function destroy() {\n\t\t\t// noop, override for your own purposes.\n\t\t\t// in listenToDOM, for example.\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.DOMListener = function DOMListener(event) {\n\t\t\t//alert('got scroll');\n\t\t\tthis.setStateFromDOM(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setStateFromDOM = function setStateFromDOM(event) {\n\t\t\tvar viewportTop = scrollTop(this.item);\n\t\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\t\tvar contentHeight = getContentHeight(this.item);\n\t\n\t\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.setState = function setState(newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\t\tvar needsRecalcuate = newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight;\n\t\n\t\t\tthis.latestEvent = event;\n\t\t\tthis.viewportTop = newViewportTop;\n\t\t\tthis.viewportHeight = newViewportHeight;\n\t\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\t\tthis.contentHeight = newContentHeight;\n\t\n\t\t\tif (needsRecalcuate) {\n\t\t\t\tvar i = this.watchers.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.updateAndTriggerWatchers(event);\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.updateAndTriggerWatchers = function updateAndTriggerWatchers(event) {\n\t\t\tvar i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].update();\n\t\t\t}\n\t\n\t\t\ti = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t\t}\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createCustomContainer = function createCustomContainer() {\n\t\t\treturn new ScrollMonitorContainer();\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.createContainer = function createContainer(item) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\t\tcontainer.setStateFromDOM();\n\t\t\tcontainer.listenToDOM();\n\t\t\treturn container;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.create = function create(item, offsets) {\n\t\t\tif (typeof item === 'string') {\n\t\t\t\titem = document.querySelector(item);\n\t\t\t} else if (item && item.length > 0) {\n\t\t\t\titem = item[0];\n\t\t\t}\n\t\t\tvar watcher = new Watcher(this, item, offsets);\n\t\t\tthis.watchers.push(watcher);\n\t\t\treturn watcher;\n\t\t};\n\t\n\t\tScrollMonitorContainer.prototype.beget = function beget(item, offsets) {\n\t\t\treturn this.create(item, offsets);\n\t\t};\n\t\n\t\treturn ScrollMonitorContainer;\n\t}();\n\t\n\tmodule.exports = ScrollMonitorContainer;\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _require = __webpack_require__(1),\n\t    VISIBILITYCHANGE = _require.VISIBILITYCHANGE,\n\t    ENTERVIEWPORT = _require.ENTERVIEWPORT,\n\t    FULLYENTERVIEWPORT = _require.FULLYENTERVIEWPORT,\n\t    EXITVIEWPORT = _require.EXITVIEWPORT,\n\t    PARTIALLYEXITVIEWPORT = _require.PARTIALLYEXITVIEWPORT,\n\t    LOCATIONCHANGE = _require.LOCATIONCHANGE,\n\t    STATECHANGE = _require.STATECHANGE,\n\t    eventTypes = _require.eventTypes,\n\t    defaultOffsets = _require.defaultOffsets;\n\t\n\tfunction ElementWatcher(containerWatcher, watchItem, offsets) {\n\t\tvar self = this;\n\t\n\t\tthis.watchItem = watchItem;\n\t\tthis.container = containerWatcher;\n\t\n\t\tif (!offsets) {\n\t\t\tthis.offsets = defaultOffsets;\n\t\t} else if (offsets === +offsets) {\n\t\t\tthis.offsets = { top: offsets, bottom: offsets };\n\t\t} else {\n\t\t\tthis.offsets = {\n\t\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t\t};\n\t\t}\n\t\n\t\tthis.callbacks = {}; // {callback: function, isOne: true }\n\t\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]] = [];\n\t\t}\n\t\n\t\tthis.locked = false;\n\t\n\t\tvar wasInViewport;\n\t\tvar wasFullyInViewport;\n\t\tvar wasAboveViewport;\n\t\tvar wasBelowViewport;\n\t\n\t\tvar listenerToTriggerListI;\n\t\tvar listener;\n\t\tfunction triggerCallbackArray(listeners, event) {\n\t\t\tif (listeners.length === 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tlistenerToTriggerListI = listeners.length;\n\t\t\twhile (listenerToTriggerListI--) {\n\t\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\t\tlistener.callback.call(self, event, self);\n\t\t\t\tif (listener.isOne) {\n\t\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tthis.triggerCallbacks = function triggerCallbacks(event) {\n\t\n\t\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t}\n\t\n\t\t\tif (this.isAboveViewport !== wasAboveViewport && this.isBelowViewport !== wasBelowViewport) {\n\t\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\n\t\t\t\t// if you skip completely past this element\n\t\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[FULLYENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[ENTERVIEWPORT], event);\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[PARTIALLYEXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[EXITVIEWPORT], event);\n\t\t\t}\n\t\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[VISIBILITYCHANGE], event);\n\t\t\t}\n\t\t\tswitch (true) {\n\t\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\t\ttriggerCallbackArray(this.callbacks[STATECHANGE], event);\n\t\t\t}\n\t\n\t\t\twasInViewport = this.isInViewport;\n\t\t\twasFullyInViewport = this.isFullyInViewport;\n\t\t\twasAboveViewport = this.isAboveViewport;\n\t\t\twasBelowViewport = this.isBelowViewport;\n\t\t};\n\t\n\t\tthis.recalculateLocation = function () {\n\t\t\tif (this.locked) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar previousTop = this.top;\n\t\t\tvar previousBottom = this.bottom;\n\t\t\tif (this.watchItem.nodeName) {\n\t\t\t\t// a dom element\n\t\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t\t}\n\t\n\t\t\t\tvar containerOffset = 0;\n\t\t\t\tvar container = this.container;\n\t\t\t\twhile (container.containerWatcher) {\n\t\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t\t}\n\t\n\t\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\t\n\t\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t\t}\n\t\t\t} else if (this.watchItem === +this.watchItem) {\n\t\t\t\t// number\n\t\t\t\tif (this.watchItem > 0) {\n\t\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t\t} else {\n\t\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// an object with a top and bottom property\n\t\t\t\tthis.top = this.watchItem.top;\n\t\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t\t}\n\t\n\t\t\tthis.top -= this.offsets.top;\n\t\t\tthis.bottom += this.offsets.bottom;\n\t\t\tthis.height = this.bottom - this.top;\n\t\n\t\t\tif ((previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom)) {\n\t\t\t\ttriggerCallbackArray(this.callbacks[LOCATIONCHANGE], null);\n\t\t\t}\n\t\t};\n\t\n\t\tthis.recalculateLocation();\n\t\tthis.update();\n\t\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\t}\n\t\n\tElementWatcher.prototype = {\n\t\ton: function on(event, callback, isOne) {\n\t\n\t\t\t// trigger the event if it applies to the element right now.\n\t\t\tswitch (true) {\n\t\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\t\tif (isOne) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t}\n\t\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tthis.callbacks[event].push({ callback: callback, isOne: isOne || false });\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to add a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\toff: function off(event, callback) {\n\t\t\tif (this.callbacks[event]) {\n\t\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type ' + event + '. Your options are: ' + eventTypes.join(', '));\n\t\t\t}\n\t\t},\n\t\tone: function one(event, callback) {\n\t\t\tthis.on(event, callback, true);\n\t\t},\n\t\trecalculateSize: function recalculateSize() {\n\t\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\t\tthis.bottom = this.top + this.height;\n\t\t},\n\t\tupdate: function update() {\n\t\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\t\n\t\t\tthis.isInViewport = this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop;\n\t\t\tthis.isFullyInViewport = this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom || this.isAboveViewport && this.isBelowViewport;\n\t\t},\n\t\tdestroy: function destroy() {\n\t\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\t    self = this;\n\t\t\tthis.container.watchers.splice(index, 1);\n\t\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t\t}\n\t\t},\n\t\t// prevent recalculating the element location\n\t\tlock: function lock() {\n\t\t\tthis.locked = true;\n\t\t},\n\t\tunlock: function unlock() {\n\t\t\tthis.locked = false;\n\t\t}\n\t};\n\t\n\tvar eventHandlerFactory = function eventHandlerFactory(type) {\n\t\treturn function (callback, isOne) {\n\t\t\tthis.on.call(this, type, callback, isOne);\n\t\t};\n\t};\n\t\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tvar type = eventTypes[i];\n\t\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n\t}\n\t\n\tmodule.exports = ElementWatcher;\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// scrollMonitor.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap b221bc136e7e9b3db562","var { isInBrowser } = require('./src/constants');\n\nvar ScrollMonitorContainer = require('./src/container');\n\nvar scrollMonitor = new ScrollMonitorContainer(isInBrowser ? document.body : null);\nscrollMonitor.setStateFromDOM(null);\nscrollMonitor.listenToDOM();\n\nif (isInBrowser) {\n\twindow.scrollMonitor = scrollMonitor;\n}\n\nmodule.exports = scrollMonitor;\n\n\n\n// WEBPACK FOOTER //\n// ./index.js","exports.VISIBILITYCHANGE = 'visibilityChange';\nexports.ENTERVIEWPORT = 'enterViewport';\nexports.FULLYENTERVIEWPORT = 'fullyEnterViewport';\nexports.EXITVIEWPORT = 'exitViewport';\nexports.PARTIALLYEXITVIEWPORT = 'partiallyExitViewport';\nexports.LOCATIONCHANGE = 'locationChange';\nexports.STATECHANGE = 'stateChange';\n\nexports.eventTypes = [\n\texports.VISIBILITYCHANGE,\n\texports.ENTERVIEWPORT,\n\texports.FULLYENTERVIEWPORT,\n\texports.EXITVIEWPORT,\n\texports.PARTIALLYEXITVIEWPORT,\n\texports.LOCATIONCHANGE,\n\texports.STATECHANGE\n];\n\nexports.isOnServer = (typeof window === 'undefined');\nexports.isInBrowser = !exports.isOnServer;\n\nexports.defaultOffsets = {top: 0, bottom: 0};\n\n\n\n// WEBPACK FOOTER //\n// ./src/constants.js","var { isOnServer, isInBrowser, eventTypes } = require('./constants');\nvar Watcher = require('./watcher');\n\nfunction getViewportHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.innerHeight || document.documentElement.clientHeight;\n\t} else {\n\t\treturn element.clientHeight;\n\t}\n}\n\nfunction getContentHeight (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\n\tif (element === document.body) {\n\t\t// jQuery approach\n\t\t// whichever is greatest\n\t\treturn Math.max(\n\t\t\tdocument.body.scrollHeight, document.documentElement.scrollHeight,\n\t\t\tdocument.body.offsetHeight, document.documentElement.offsetHeight,\n\t\t\tdocument.documentElement.clientHeight\n\t\t);\n\t} else {\n\t\treturn element.scrollHeight;\n\t}\n}\n\nfunction scrollTop (element) {\n\tif (isOnServer) {\n\t\treturn 0;\n\t}\n\tif (element === document.body) {\n\t\treturn window.pageYOffset ||\n\t\t\t(document.documentElement && document.documentElement.scrollTop) ||\n\t\t\tdocument.body.scrollTop;\n\t} else {\n\t\treturn element.scrollTop;\n\t}\n}\n\nvar browserSupportsPassive = false;\nif (isInBrowser) {\n\ttry {\n\t\tvar opts = Object.defineProperty({}, 'passive', {\n\t\t\tget: function() {\n\t\t\t\tbrowserSupportsPassive = true;\n\t\t\t}\n\t\t});\n\t\twindow.addEventListener('test', null, opts);\n\t} catch (e) {}\n}\nconst useCapture = browserSupportsPassive ? {capture: false, passive: true} : false;\n\n\nclass ScrollMonitorContainer {\n\tconstructor (item, parentWatcher) {\n\t\tvar self = this;\n\n\t\tthis.item = item;\n\t\tthis.watchers = [];\n\t\tthis.viewportTop = null;\n\t\tthis.viewportBottom = null;\n\t\tthis.documentHeight = getContentHeight(item);\n\t\tthis.viewportHeight = getViewportHeight(item);\n\t\tthis.DOMListener = function () {\n\t\t\tScrollMonitorContainer.prototype.DOMListener.apply(self, arguments);\n\t\t};\n\t\tthis.eventTypes = eventTypes;\n\n\t\tif (parentWatcher) {\n\t\t\tthis.containerWatcher = parentWatcher.create(item);\n\t\t}\n\n\t\tvar previousDocumentHeight;\n\n\t\tvar calculateViewportI;\n\t\tfunction calculateViewport() {\n\t\t\tself.viewportTop = scrollTop(item);\n\t\t\tself.viewportBottom = self.viewportTop + self.viewportHeight;\n\t\t\tself.documentHeight = getContentHeight(item);\n\t\t\tif (self.documentHeight !== previousDocumentHeight) {\n\t\t\t\tcalculateViewportI = self.watchers.length;\n\t\t\t\twhile( calculateViewportI-- ) {\n\t\t\t\t\tself.watchers[calculateViewportI].recalculateLocation();\n\t\t\t\t}\n\t\t\t\tpreviousDocumentHeight = self.documentHeight;\n\t\t\t}\n\t\t}\n\n\t\tvar updateAndTriggerWatchersI;\n\t\tfunction updateAndTriggerWatchers() {\n\t\t\t// update all watchers then trigger the events so one can rely on another being up to date.\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].update();\n\t\t\t}\n\n\t\t\tupdateAndTriggerWatchersI = self.watchers.length;\n\t\t\twhile( updateAndTriggerWatchersI-- ) {\n\t\t\t\tself.watchers[updateAndTriggerWatchersI].triggerCallbacks();\n\t\t\t}\n\n\t\t}\n\n\t\tthis.update = function() {\n\t\t\tcalculateViewport();\n\t\t\tupdateAndTriggerWatchers();\n\t\t};\n\t\tthis.recalculateLocations = function() {\n\t\t\tthis.documentHeight = 0;\n\t\t\tthis.update();\n\t\t};\n\n\t}\n\n\tlistenToDOM () {\n\t\tif (isInBrowser) {\n\t\t\tif (window.addEventListener) {\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.addEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t}\n\t\t\t\twindow.addEventListener('resize', this.DOMListener);\n\t\t\t} else {\n\t\t\t\t// Old IE support\n\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\twindow.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\tthis.item.attachEvent('onscroll', this.DOMListener);\n\t\t\t\t}\n\t\t\t\twindow.attachEvent('onresize', this.DOMListener);\n\t\t\t}\n\t\t\tthis.destroy = function () {\n\t\t\t\tif (window.addEventListener) {\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.removeEventListener('scroll', this.DOMListener, useCapture);\n\t\t\t\t\t}\n\t\t\t\t\twindow.removeEventListener('resize', this.DOMListener);\n\t\t\t\t} else {\n\t\t\t\t\t// Old IE support\n\t\t\t\t\tif (this.item === document.body) {\n\t\t\t\t\t\twindow.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t\tthis.containerWatcher.destroy();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.item.detachEvent('onscroll', this.DOMListener);\n\t\t\t\t\t}\n\t\t\t\t\twindow.detachEvent('onresize', this.DOMListener);\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n\n\tdestroy () {\n\t\t// noop, override for your own purposes.\n\t\t// in listenToDOM, for example.\n\t}\n\n\tDOMListener (event) {\n\t\t//alert('got scroll');\n\t\tthis.setStateFromDOM(event);\n\t}\n\n\tsetStateFromDOM (event) {\n\t\tvar viewportTop = scrollTop(this.item);\n\t\tvar viewportHeight = getViewportHeight(this.item);\n\t\tvar contentHeight = getContentHeight(this.item);\n\n\t\tthis.setState(viewportTop, viewportHeight, contentHeight, event);\n\t}\n\n\tsetState (newViewportTop, newViewportHeight, newContentHeight, event) {\n\t\tvar needsRecalcuate = (newViewportHeight !== this.viewportHeight || newContentHeight !== this.contentHeight);\n\n\t\tthis.latestEvent = event;\n\t\tthis.viewportTop = newViewportTop;\n\t\tthis.viewportHeight = newViewportHeight;\n\t\tthis.viewportBottom = newViewportTop + newViewportHeight;\n\t\tthis.contentHeight = newContentHeight;\n\n\t\tif (needsRecalcuate) {\n\t\t\tlet i = this.watchers.length;\n\t\t\twhile (i--) {\n\t\t\t\tthis.watchers[i].recalculateLocation();\n\t\t\t}\n\t\t}\n\t\tthis.updateAndTriggerWatchers(event);\n\t}\n\n\tupdateAndTriggerWatchers (event) {\n\t\tlet i = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].update();\n\t\t}\n\n\t\ti = this.watchers.length;\n\t\twhile (i--) {\n\t\t\tthis.watchers[i].triggerCallbacks(event);\n\t\t}\n\t}\n\n\tcreateCustomContainer () {\n\t\treturn new ScrollMonitorContainer();\n\t}\n\n\tcreateContainer (item) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar container = new ScrollMonitorContainer(item, this);\n\t\tcontainer.setStateFromDOM();\n\t\tcontainer.listenToDOM();\n\t\treturn container;\n\t}\n\n\tcreate (item, offsets) {\n\t\tif (typeof item === 'string') {\n\t\t\titem = document.querySelector(item);\n\t\t} else if (item && item.length > 0) {\n\t\t\titem = item[0];\n\t\t}\n\t\tvar watcher = new Watcher(this, item, offsets);\n\t\tthis.watchers.push(watcher);\n\t\treturn watcher;\n\t}\n\n\tbeget (item, offsets) {\n\t\treturn this.create(item, offsets);\n\t}\n}\n\nmodule.exports = ScrollMonitorContainer;\n\n\n\n\n// WEBPACK FOOTER //\n// ./src/container.js","var {\n\tVISIBILITYCHANGE,\n\tENTERVIEWPORT,\n\tFULLYENTERVIEWPORT,\n\tEXITVIEWPORT,\n\tPARTIALLYEXITVIEWPORT,\n\tLOCATIONCHANGE,\n\tSTATECHANGE,\n\teventTypes,\n\tdefaultOffsets\n} = require('./constants');\n\nfunction ElementWatcher (containerWatcher, watchItem, offsets) {\n\tvar self = this;\n\n\tthis.watchItem = watchItem;\n\tthis.container = containerWatcher;\n\n\tif (!offsets) {\n\t\tthis.offsets = defaultOffsets;\n\t} else if (offsets === +offsets) {\n\t\tthis.offsets = {top: offsets, bottom: offsets};\n\t} else {\n\t\tthis.offsets = {\n\t\t\ttop: offsets.top || defaultOffsets.top,\n\t\t\tbottom: offsets.bottom || defaultOffsets.bottom\n\t\t};\n\t}\n\n\tthis.callbacks = {}; // {callback: function, isOne: true }\n\n\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\tself.callbacks[eventTypes[i]] = [];\n\t}\n\n\tthis.locked = false;\n\n\tvar wasInViewport;\n\tvar wasFullyInViewport;\n\tvar wasAboveViewport;\n\tvar wasBelowViewport;\n\n\tvar listenerToTriggerListI;\n\tvar listener;\n\tfunction triggerCallbackArray (listeners, event) {\n\t\tif (listeners.length === 0) {\n\t\t\treturn;\n\t\t}\n\t\tlistenerToTriggerListI = listeners.length;\n\t\twhile (listenerToTriggerListI--) {\n\t\t\tlistener = listeners[listenerToTriggerListI];\n\t\t\tlistener.callback.call(self, event, self);\n\t\t\tif (listener.isOne) {\n\t\t\t\tlisteners.splice(listenerToTriggerListI, 1);\n\t\t\t}\n\t\t}\n\t}\n\tthis.triggerCallbacks = function triggerCallbacks (event) {\n\n\t\tif (this.isInViewport && !wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t}\n\t\tif (this.isFullyInViewport && !wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t}\n\n\n\t\tif (this.isAboveViewport !== wasAboveViewport &&\n\t\t\tthis.isBelowViewport !== wasBelowViewport) {\n\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\n\t\t\t// if you skip completely past this element\n\t\t\tif (!wasFullyInViewport && !this.isFullyInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[FULLYENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t\t}\n\t\t\tif (!wasInViewport && !this.isInViewport) {\n\t\t\t\ttriggerCallbackArray( this.callbacks[ENTERVIEWPORT], event );\n\t\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t\t}\n\t\t}\n\n\t\tif (!this.isFullyInViewport && wasFullyInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[PARTIALLYEXITVIEWPORT], event );\n\t\t}\n\t\tif (!this.isInViewport && wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[EXITVIEWPORT], event );\n\t\t}\n\t\tif (this.isInViewport !== wasInViewport) {\n\t\t\ttriggerCallbackArray( this.callbacks[VISIBILITYCHANGE], event );\n\t\t}\n\t\tswitch( true ) {\n\t\t\tcase wasInViewport !== this.isInViewport:\n\t\t\tcase wasFullyInViewport !== this.isFullyInViewport:\n\t\t\tcase wasAboveViewport !== this.isAboveViewport:\n\t\t\tcase wasBelowViewport !== this.isBelowViewport:\n\t\t\t\ttriggerCallbackArray( this.callbacks[STATECHANGE], event );\n\t\t}\n\n\t\twasInViewport = this.isInViewport;\n\t\twasFullyInViewport = this.isFullyInViewport;\n\t\twasAboveViewport = this.isAboveViewport;\n\t\twasBelowViewport = this.isBelowViewport;\n\n\t};\n\n\tthis.recalculateLocation = function () {\n\t\tif (this.locked) {\n\t\t\treturn;\n\t\t}\n\t\tvar previousTop = this.top;\n\t\tvar previousBottom = this.bottom;\n\t\tif (this.watchItem.nodeName) { // a dom element\n\t\t\tvar cachedDisplay = this.watchItem.style.display;\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = '';\n\t\t\t}\n\n\t\t\tvar containerOffset = 0;\n\t\t\tvar container = this.container;\n\t\t\twhile (container.containerWatcher) {\n\t\t\t\tcontainerOffset += container.containerWatcher.top - container.containerWatcher.container.viewportTop;\n\t\t\t\tcontainer = container.containerWatcher.container;\n\t\t\t}\n\n\t\t\tvar boundingRect = this.watchItem.getBoundingClientRect();\n\t\t\tthis.top = boundingRect.top + this.container.viewportTop - containerOffset;\n\t\t\tthis.bottom = boundingRect.bottom + this.container.viewportTop - containerOffset;\n\n\t\t\tif (cachedDisplay === 'none') {\n\t\t\t\tthis.watchItem.style.display = cachedDisplay;\n\t\t\t}\n\n\t\t} else if (this.watchItem === +this.watchItem) { // number\n\t\t\tif (this.watchItem > 0) {\n\t\t\t\tthis.top = this.bottom = this.watchItem;\n\t\t\t} else {\n\t\t\t\tthis.top = this.bottom = this.container.documentHeight - this.watchItem;\n\t\t\t}\n\n\t\t} else { // an object with a top and bottom property\n\t\t\tthis.top = this.watchItem.top;\n\t\t\tthis.bottom = this.watchItem.bottom;\n\t\t}\n\n\t\tthis.top -= this.offsets.top;\n\t\tthis.bottom += this.offsets.bottom;\n\t\tthis.height = this.bottom - this.top;\n\n\t\tif ( (previousTop !== undefined || previousBottom !== undefined) && (this.top !== previousTop || this.bottom !== previousBottom) ) {\n\t\t\ttriggerCallbackArray( this.callbacks[LOCATIONCHANGE], null );\n\t\t}\n\t};\n\n\tthis.recalculateLocation();\n\tthis.update();\n\n\twasInViewport = this.isInViewport;\n\twasFullyInViewport = this.isFullyInViewport;\n\twasAboveViewport = this.isAboveViewport;\n\twasBelowViewport = this.isBelowViewport;\n}\n\nElementWatcher.prototype = {\n\ton: function (event, callback, isOne) {\n\n\t\t// trigger the event if it applies to the element right now.\n\t\tswitch( true ) {\n\t\t\tcase event === VISIBILITYCHANGE && !this.isInViewport && this.isAboveViewport:\n\t\t\tcase event === ENTERVIEWPORT && this.isInViewport:\n\t\t\tcase event === FULLYENTERVIEWPORT && this.isFullyInViewport:\n\t\t\tcase event === EXITVIEWPORT && this.isAboveViewport && !this.isInViewport:\n\t\t\tcase event === PARTIALLYEXITVIEWPORT && this.isInViewport && this.isAboveViewport:\n\t\t\t\tcallback.call(this, this.container.latestEvent, this);\n\t\t\t\tif (isOne) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t}\n\n\t\tif (this.callbacks[event]) {\n\t\t\tthis.callbacks[event].push({callback: callback, isOne: isOne||false});\n\t\t} else {\n\t\t\tthrow new Error('Tried to add a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\toff: function( event, callback ) {\n\t\tif (this.callbacks[event]) {\n\t\t\tfor (var i = 0, item; item = this.callbacks[event][i]; i++) {\n\t\t\t\tif (item.callback === callback) {\n\t\t\t\t\tthis.callbacks[event].splice(i, 1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new Error('Tried to remove a scroll monitor listener of type '+event+'. Your options are: '+eventTypes.join(', '));\n\t\t}\n\t},\n\tone: function( event, callback ) {\n\t\tthis.on( event, callback, true);\n\t},\n\trecalculateSize: function() {\n\t\tthis.height = this.watchItem.offsetHeight + this.offsets.top + this.offsets.bottom;\n\t\tthis.bottom = this.top + this.height;\n\t},\n\tupdate: function() {\n\t\tthis.isAboveViewport = this.top < this.container.viewportTop;\n\t\tthis.isBelowViewport = this.bottom > this.container.viewportBottom;\n\n\t\tthis.isInViewport = (this.top < this.container.viewportBottom && this.bottom > this.container.viewportTop);\n\t\tthis.isFullyInViewport = (this.top >= this.container.viewportTop && this.bottom <= this.container.viewportBottom) || (this.isAboveViewport && this.isBelowViewport);\n\n\t},\n\tdestroy: function() {\n\t\tvar index = this.container.watchers.indexOf(this),\n\t\t\tself  = this;\n\t\tthis.container.watchers.splice(index, 1);\n\t\tfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\t\t\tself.callbacks[eventTypes[i]].length = 0;\n\t\t}\n\t},\n\t// prevent recalculating the element location\n\tlock: function() {\n\t\tthis.locked = true;\n\t},\n\tunlock: function() {\n\t\tthis.locked = false;\n\t}\n};\n\nvar eventHandlerFactory = function (type) {\n\treturn function( callback, isOne ) {\n\t\tthis.on.call(this, type, callback, isOne);\n\t};\n};\n\nfor (var i = 0, j = eventTypes.length; i < j; i++) {\n\tvar type =  eventTypes[i];\n\tElementWatcher.prototype[type] = eventHandlerFactory(type);\n}\n\nmodule.exports = ElementWatcher;\n\n\n\n// WEBPACK FOOTER //\n// ./src/watcher.js"],"sourceRoot":""}